@page "/draw"
@inject IJSRuntime JSRuntime
@inject IShapeCalculatorService ShapeCalculatorService
@inject IShapeHandlerService ShapeHandlerService
@inject ICanvasInteropService CanvasInteropService

@rendermode InteractiveServer
<h3>Draw a Shape</h3>

<div class="d-flex flex-wrap">
    <div class="flex-grow-1 position-relative">
        <img src="floor_map_3.jpg" class="img-fluid" />
        <canvas id="drawingCanvas" class="position-absolute top-0 start-0" style="border: 1px solid black;" width="414" height="580"></canvas>
    </div>
    <div class="flex-grow-1 p-3">
        <div>
            <label for="realLifeDistance">Real-life Distance (meters):</label>
            <input type="number" @bind="realLifeDistance" id="realLifeDistance" class="form-control mb-3" />
            <button @onclick="SetReferenceLine" class="btn btn-primary mb-3">Set Reference Line</button>
        </div>
        <p>Area: @area square meters</p>

        @if (shapeInformation.Count > 0)
        {
            <h4>Shapes Created:</h4>
            <ul>
                @foreach (var shapeInfo in shapeInformation)
                {
                    <li>@shapeInfo</li>
                }
            </ul>
        }
    </div>
</div>

@code {
    private double area = 0.0;
    private List<List<Point>> shapes = new();
    private List<string> shapeInformation = new();
    private DotNetObjectReference<Draw> dotNetObjectRef = null!;
    private double realLifeDistance;
    private double pixelsPerMeter;
    private bool settingReferenceLine = true;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            dotNetObjectRef = DotNetObjectReference.Create(this);
            await CanvasInteropService.Initialize(dotNetObjectRef, "drawingCanvas");
        }
    }

    [JSInvokable]
    public void ShapeClosed(List<List<Point>> closedShapes)
    {
        shapes = closedShapes;

        shapeInformation.Clear();
        area = ShapeHandlerService.CalculateShapeArea(shapes, pixelsPerMeter, shapeInformation);

        StateHasChanged();
    }

    [JSInvokable]
    public void SetPixelsPerMeter(double referenceLength)
    {
        pixelsPerMeter = referenceLength / realLifeDistance;
        settingReferenceLine = false;
    }

    private async Task SetReferenceLine()
    {
        settingReferenceLine = true;
        await CanvasInteropService.StartReferenceLine();
    }

    public void Dispose()
    {
        dotNetObjectRef?.Dispose();
    }

}
@page "/draw"
@inject IJSRuntime JSRuntime
@inject IShapeCalculatorService ShapeCalculatorService
@inject IShapeHandlerService ShapeHandlerService
@inject ICanvasInteropService CanvasInteropService

@rendermode InteractiveServer
<style>
    .canvas-container {
        position: relative;
        width: 414px;
        height: 580px;
    }

    .guidelines-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        background-image: linear-gradient(to right, rgba(0, 0, 0, 0.1) 1px, transparent 1px), linear-gradient(to bottom, rgba(0, 0, 0, 0.1) 1px, transparent 1px);
        background-size: 10px 10px;
        display: none;
    }
</style>

<h3>Draw a Shape</h3>
<div class="d-flex flex-wrap">
    <div class="flex-grow-1 position-relative">
        <div class="canvas-container position-relative">
            <canvas id="drawingCanvas"></canvas>
            <div class="guidelines-overlay position-absolute top-0 start-0"></div>
        </div>
    </div>
    <div class="flex-grow-1 p-3">
        <div>
            <label for="realLifeDistance">Real-life Distance (meters):</label>
            <input type="number" @bind="realLifeDistance" id="realLifeDistance" class="form-control mb-3" />
            <button @onclick="SetReferenceLine" class="btn btn-primary mb-3">Set Reference Line</button>
            <button @onclick="UndoLastAction" class="btn btn-secondary mb-3">Undo</button>
            <button @onclick="RedoLastAction" class="btn btn-secondary mb-3">Redo</button>
            <button @onclick="SaveEdits" class="btn btn-success mb-3">Save Edits</button>
        </div>
        <p>Area: @area square meters</p>

        @if (shapeInfos.Count > 0)
        {
            <h4>Shapes Created:</h4>
            <ul>
                @foreach (var shapeInfo in shapeInfos)
                {
                    <li>
                        @shapeInfo.Area
                        <button @onclick="() => SelectShape(shapeInfos.IndexOf(shapeInfo))" class="btn btn-warning btn-sm">Edit</button>
                        <button @onclick="() => DeleteShape(shapeInfos.IndexOf(shapeInfo))" class="btn btn-danger btn-sm">Delete</button>
                    </li>
                }
            </ul>
        }
    </div>
</div>

@code {
    private double area = 0.0;
    private List<List<Point>> shapes = new();
    private List<ShapeInfo> shapeInfos = new();
    private DotNetObjectReference<Draw> dotNetObjectRef = null!;
    private double realLifeDistance;
    private double pixelsPerMeter;
    private bool settingReferenceLine = true;
    private bool displayGridGuidelines = false;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            dotNetObjectRef = DotNetObjectReference.Create(this);
            await CanvasInteropService.Initialize(dotNetObjectRef, "drawingCanvas");
        }
    }

    [JSInvokable]
    public void ShapeClosed(List<List<Point>> closedShapes)
    {
        shapes = closedShapes;
        UpdateShapeInformation();
    }

    [JSInvokable]
    public void SetPixelsPerMeter(double referenceLength)
    {
        pixelsPerMeter = referenceLength / realLifeDistance;
        settingReferenceLine = false;
        UpdateGuidelinesOverlay();
        UpdateShapeInformation();
    }

    [JSInvokable]
    public void UpdateShapes(List<List<Point>> updatedShapes)
    {
        shapes = updatedShapes;
        UpdateShapeInformation();
    }

    private async Task SetReferenceLine()
    {
        settingReferenceLine = true;
        await CanvasInteropService.StartReferenceLine();
    }

    private async Task UndoLastAction()
    {
        await JSRuntime.InvokeVoidAsync("canvasInterop.undoLastAction");
    }

    private async Task RedoLastAction()
    {
        await JSRuntime.InvokeVoidAsync("canvasInterop.redoLastAction");
    }

    private async Task SaveEdits()
    {
        await JSRuntime.InvokeVoidAsync("canvasInterop.saveEdits");
    }

    private async Task SelectShape(int index)
    {
        await JSRuntime.InvokeVoidAsync("canvasInterop.selectShape", index);
    }

    private async Task DeleteShape(int index)
    {
        await JSRuntime.InvokeVoidAsync("canvasInterop.deleteShape", index);
    }

    private void UpdateShapeInformation()
    {
        shapeInfos.Clear();
        var shapesToCalculate = shapes.Select(s => s.Select(p => new Point(p.X / pixelsPerMeter, p.Y / pixelsPerMeter)).ToList()).ToList();
        var calculatedShapes = ShapeHandlerService.CalculateShapeArea(shapesToCalculate);
        shapeInfos.AddRange(calculatedShapes);
        area = shapeInfos.Sum(si => si.Area);
        StateHasChanged();
    }

    private async Task UpdateGuidelinesOverlay()
    {
        var overlay = await JSRuntime.InvokeAsync<IJSObjectReference>("document.querySelector", ".guidelines-overlay");

        if (overlay != null)
        {
            await overlay.InvokeVoidAsync("setAttribute", "style", $"background-size: {pixelsPerMeter}px {pixelsPerMeter}px; display: block;");
            displayGridGuidelines = true;
            StateHasChanged();
        }
    }

    public void Dispose()
    {
        dotNetObjectRef?.Dispose();
    }
}
